Week 1:
Robustness is a very important part of programming, formal verification is hard probably (TODO is it?)
Curry-Howard-Lambek correspondence - already a thing in haskell, can prove things with first order logic
- A type is equivalent to a logical expression and a value of the type is a proof of that expression
- Can only do propositional logic
Intuitionistic type theory is dependent types which is what idris uses
- Isomorphic to first or second (TODO) order logic
- Very different to assembly types
- Types like tuples and functions can have the types of later parts dependent on the values of earlier parts
Simply typed lambda calculus:
- All constructed types are functions
- Church encodings don't map very well to assembly
System F:
- Passing types around like values is intuitive and easy to grasp
- Still not a good map to assembly
Refinement types:
- Not part of the lambda cube
- Maps very well to assembly

SMT:
- Will use theories of: bitvectors, arrays, algebraic datatypes, structs
- bitvectors for ints and floats
- float bitvectors use IEEE 754 standard. LLVM also needs to use IEEE in order to be correct. I think it does since all modern widely used CPUs use IEEE and that's what LLVM will compile into
- Arrays are mutable, similar to ocaml. They compile to just pointers as in C. They have a fixed length
- Lists can be constructed from algebraic datatypes and will be in the standard library
- Structs will be completely abstracted by the compiler so Z3 doesn't care about them particularly

Suppose I want to assign a value of type v to a variable of type t. Assume both are ints with predicates v and t respectively in Z3:
(declare-const x Int)
(assert (v x))
(assert (forall ((y Int))
	(or (t y) (not (= y x)))))
(check-sat)
Will be unsat if the assignment is valid, or sat if not and the model for sat is a value which the value could be but the type can't take so is useful for the compilers error message
These predicates will take the form of a bunch of existential quantifiers, and then an expression with no quantifiers.
These will need to be translated to Z3, all the existential quantifiers are effectively a variable in the sat code and the negation makes them all universal quantifiers so each is a variable in the forall assertion

Investigation:
- Idris, Coq
- Limits of each SMT theory
- Advantages over other CAFV methods
https://nikita-volkov.github.io/refined/
- Papers on refinement types
- Write a grammar
- Reduction relations
- Typing rules

Jam wants to use an advanced type theory but not abstract too far from llvm bytecode.
Thus it sits close to lambda C but additional restrictions can be put in place to only allow binding to a certain supertype.
This is how refinement type functionality is achieved.
This hopefully is very intuitive as all this can be achieved simply by making types like values.
The challenge is to be functional while still keeping the mapping to llvm simple.
Complex code has a lot of bugs, so part of making jam robust is keeping the compilation process simple and predictable.
It should be possible to step through the llvm bytecode in order to debug it and see what maps to what.
It will also have eager evaluation which makes side effects easy to implement.

Questions:
